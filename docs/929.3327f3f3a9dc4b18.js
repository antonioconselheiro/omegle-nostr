(()=>{"use strict";var it={d:(t,e)=>{for(var n in e)it.o(e,n)&&!it.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},Rt={};function Ct(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function $t(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function wt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}it.r(Rt),it.d(Rt,{OG:()=>Gt,My:()=>ut,Ph:()=>j,lX:()=>zt,Id:()=>ct,fg:()=>pe,qj:()=>C,aT:()=>lt,lq:()=>Q,z:()=>Kt,Q5:()=>pt});const jt="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,Vt=t=>t instanceof Uint8Array,Pt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),G=(t,e)=>t<<32-e|t>>>e;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function yt(t){if("string"==typeof t&&(t=function ze(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!Vt(t))throw new Error("expected Uint8Array, got "+typeof t);return t}class de{clone(){return this._cloneInto()}}function Me(t){const e=r=>t().update(yt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function he(t=32){if(jt&&"function"==typeof jt.getRandomValues)return jt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class Ye extends de{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Pt(this.buffer)}update(e){wt(this);const{view:n,buffer:r,blockLen:o}=this,s=(e=yt(e)).length;for(let c=0;c<s;){const i=Math.min(o-this.pos,s-c);if(i!==o)r.set(e.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===o&&(this.process(n,0),this.pos=0);else{const f=Pt(e);for(;o<=s-c;c+=o)this.process(f,c)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){wt(this),function le(t,e){$t(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:c}=this;n[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let a=c;a<o;a++)n[a]=0;(function We(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),c=Number(n>>o&s),i=Number(n&s),u=r?0:4;t.setUint32(e+(r?4:0),c,r),t.setUint32(e+u,i,r)})(r,o-8,BigInt(8*this.length),s),this.process(r,0);const i=Pt(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=f/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let a=0;a<u;a++)i.setUint32(4*a,d[a],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:c,pos:i}=this;return e.length=o,e.pos=i,e.finished=s,e.destroyed=c,o%n&&e.buffer.set(r),e}}const Xe=(t,e,n)=>t&e^~t&n,Qe=(t,e,n)=>t&e^t&n^e&n,Je=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Y=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),X=new Uint32Array(64);class ge extends Ye{constructor(){super(64,32,8,!1),this.A=0|Y[0],this.B=0|Y[1],this.C=0|Y[2],this.D=0|Y[3],this.E=0|Y[4],this.F=0|Y[5],this.G=0|Y[6],this.H=0|Y[7]}get(){const{A:e,B:n,C:r,D:o,E:s,F:c,G:i,H:f}=this;return[e,n,r,o,s,c,i,f]}set(e,n,r,o,s,c,i,f){this.A=0|e,this.B=0|n,this.C=0|r,this.D=0|o,this.E=0|s,this.F=0|c,this.G=0|i,this.H=0|f}process(e,n){for(let a=0;a<16;a++,n+=4)X[a]=e.getUint32(n,!1);for(let a=16;a<64;a++){const E=X[a-15],B=X[a-2],p=G(E,7)^G(E,18)^E>>>3,l=G(B,17)^G(B,19)^B>>>10;X[a]=l+X[a-7]+p+X[a-16]|0}let{A:r,B:o,C:s,D:c,E:i,F:f,G:u,H:d}=this;for(let a=0;a<64;a++){const B=d+(G(i,6)^G(i,11)^G(i,25))+Xe(i,f,u)+Je[a]+X[a]|0,l=(G(r,2)^G(r,13)^G(r,22))+Qe(r,o,s)|0;d=u,u=f,f=i,i=c+B|0,c=s,s=o,o=r,r=B+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,i=i+this.E|0,f=f+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(r,o,s,c,i,f,u,d)}roundClean(){X.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Dt=Me(()=>new ge),Bt=(BigInt(0),BigInt(1)),Fe=BigInt(2),_t=t=>t instanceof Uint8Array,tn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function ut(t){if(!_t(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=tn[t[n]];return e}function we(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}function lt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const o=2*r,s=t.slice(o,o+2),c=Number.parseInt(s,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");n[r]=c}return n}function j(t){return we(ut(t))}function zt(t){if(!_t(t))throw new Error("Uint8Array expected");return we(ut(Uint8Array.from(t).reverse()))}function Q(t,e){return lt(t.toString(16).padStart(2*e,"0"))}function Kt(t,e){return Q(t,e).reverse()}function C(t,e,n){let r;if("string"==typeof e)try{r=lt(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else{if(!_t(e))throw new Error(`${t} must be hex string or Uint8Array`);r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function ct(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!_t(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}const Gt=t=>(Fe<<BigInt(t-1))-Bt,Mt=t=>new Uint8Array(t),ye=t=>Uint8Array.from(t);function pe(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=Mt(t),o=Mt(t),s=0;const c=()=>{r.fill(1),o.fill(0),s=0},i=(...a)=>n(o,r,...a),f=(a=Mt())=>{o=i(ye([0]),a),r=i(),0!==a.length&&(o=i(ye([1]),a),r=i())},u=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let a=0;const E=[];for(;a<e;){r=i();const B=r.slice();E.push(B),a+=r.length}return ct(...E)};return(a,E)=>{let B;for(c(),f(a);!(B=E(u()));)f();return c(),B}}const nn={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function pt(t,e,n={}){const r=(o,s,c)=>{const i=nn[s];if("function"!=typeof i)throw new Error(`Invalid validator "${s}", expected function`);const f=t[o];if(!(c&&void 0===f||i(f,t)))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${s}`)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}const H=BigInt(0),L=BigInt(1),J=BigInt(2),rn=BigInt(3),Wt=BigInt(4),xe=BigInt(5),me=BigInt(8);function k(t,e){const n=t%e;return n>=H?n:e+n}function cn(t,e,n){if(n<=H||e<H)throw new Error("Expected power/modulo > 0");if(n===L)return H;let r=L;for(;e>H;)e&L&&(r=r*t%n),t=t*t%n,e>>=L;return r}function z(t,e,n){let r=t;for(;e-- >H;)r*=r,r%=n;return r}function vt(t,e){if(t===H||e<=H)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=k(t,e),r=e,o=H,s=L,c=L,i=H;for(;n!==H;){const u=r/n,d=r%n,a=o-c*u,E=s-i*u;r=n,n=d,o=c,s=i,c=a,i=E}if(r!==L)throw new Error("invert: does not exist");return k(o,e)}BigInt(9),BigInt(16);const un=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Yt(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function Ee(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Be(t){const e=Ee(t);return e+Math.ceil(e/2)}class _e extends de{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,function ue(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");Ct(t.outputLen),Ct(t.blockLen)}(e);const r=yt(n);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=e.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(e){return wt(this),this.iHash.update(e),this}digestInto(e){wt(this),$t(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:c,outputLen:i}=this;return e.finished=o,e.destroyed=s,e.blockLen=c,e.outputLen=i,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ve=(t,e,n)=>new _e(t,e).update(n).digest();ve.create=(t,e)=>new _e(t,e);const wn=BigInt(0),Xt=BigInt(1);function Ae(t){return function ln(t){pt(t,un.reduce((r,o)=>(r[o]="function",r),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}(t.Fp),pt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Yt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const{Ph:xn,aT:mn}=Rt,ft={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=ft;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(128&r[0])throw new e("Invalid signature integer: negative");if(0===r[0]&&!(128&r[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:xn(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=ft,n="string"==typeof t?mn(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||48!=n[0])throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:s}=ft._parseInt(n.subarray(2)),{d:c,l:i}=ft._parseInt(s);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:c}},hexFromSig(t){const e=u=>8&Number.parseInt(u[0],16)?"00"+u:u,n=u=>{const d=u.toString(16);return 1&d.length?`0${d}`:d},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,c=o.length/2,i=n(s),f=n(c);return`30${n(c+s+4)}02${f}${o}02${i}${r}`}},K=BigInt(0),N=BigInt(1),At=(BigInt(2),BigInt(3));function _n(t){const e=function Bn(t){const e=Ae(t);return pt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r}=e,o=n.BYTES+1,s=2*n.BYTES+1;function i(b){return k(b,r)}function f(b){return vt(b,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:d,weierstrassEquation:a,isWithinCurveOrder:E}=function En(t){const e=function pn(t){const e=Ae(t);pt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,r=e.toBytes||((p,l,h)=>{const g=l.toAffine();return ct(Uint8Array.from([4]),n.toBytes(g.x),n.toBytes(g.y))}),o=e.fromBytes||(p=>{const l=p.subarray(1);return{x:n.fromBytes(l.subarray(0,n.BYTES)),y:n.fromBytes(l.subarray(n.BYTES,2*n.BYTES))}});function s(p){const{a:l,b:h}=e,g=n.sqr(p),w=n.mul(g,p);return n.add(n.add(w,n.mul(p,l)),h)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function c(p){return"bigint"==typeof p&&K<p&&p<e.n}function i(p){if(!c(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(p){const{allowedPrivateKeyLengths:l,nByteLength:h,wrapPrivateKey:g,n:w}=e;if(l&&"bigint"!=typeof p){if(p instanceof Uint8Array&&(p=ut(p)),"string"!=typeof p||!l.includes(p.length))throw new Error("Invalid key");p=p.padStart(2*h,"0")}let x;try{x="bigint"==typeof p?p:j(C("private key",p,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof p}`)}return g&&(x=k(x,w)),i(x),x}const u=new Map;function d(p){if(!(p instanceof a))throw new Error("ProjectivePoint expected")}class a{constructor(l,h,g){if(this.px=l,this.py=h,this.pz=g,null==l||!n.isValid(l))throw new Error("x required");if(null==h||!n.isValid(h))throw new Error("y required");if(null==g||!n.isValid(g))throw new Error("z required")}static fromAffine(l){const{x:h,y:g}=l||{};if(!l||!n.isValid(h)||!n.isValid(g))throw new Error("invalid affine point");if(l instanceof a)throw new Error("projective point not allowed");const w=x=>n.eql(x,n.ZERO);return w(h)&&w(g)?a.ZERO:new a(h,g,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const h=n.invertBatch(l.map(g=>g.pz));return l.map((g,w)=>g.toAffine(h[w])).map(a.fromAffine)}static fromHex(l){const h=a.fromAffine(o(C("pointHex",l)));return h.assertValidity(),h}static fromPrivateKey(l){return a.BASE.multiply(f(l))}_setWindowSize(l){this._WINDOW_SIZE=l,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:h}=this.toAffine();if(!n.isValid(l)||!n.isValid(h))throw new Error("bad point: x or y not FE");const g=n.sqr(h),w=s(l);if(!n.eql(g,w))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){d(l);const{px:h,py:g,pz:w}=this,{px:x,py:v,pz:S}=l,m=n.eql(n.mul(h,S),n.mul(x,w)),_=n.eql(n.mul(g,S),n.mul(v,w));return m&&_}negate(){return new a(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:h}=e,g=n.mul(h,At),{px:w,py:x,pz:v}=this;let S=n.ZERO,m=n.ZERO,_=n.ZERO,A=n.mul(w,w),$=n.mul(x,x),q=n.mul(v,v),O=n.mul(w,x);return O=n.add(O,O),_=n.mul(w,v),_=n.add(_,_),S=n.mul(l,_),m=n.mul(g,q),m=n.add(S,m),S=n.sub($,m),m=n.add($,m),m=n.mul(S,m),S=n.mul(O,S),_=n.mul(g,_),q=n.mul(l,q),O=n.sub(A,q),O=n.mul(l,O),O=n.add(O,_),_=n.add(A,A),A=n.add(_,A),A=n.add(A,q),A=n.mul(A,O),m=n.add(m,A),q=n.mul(x,v),q=n.add(q,q),A=n.mul(q,O),S=n.sub(S,A),_=n.mul(q,$),_=n.add(_,_),_=n.add(_,_),new a(S,m,_)}add(l){d(l);const{px:h,py:g,pz:w}=this,{px:x,py:v,pz:S}=l;let m=n.ZERO,_=n.ZERO,A=n.ZERO;const $=e.a,q=n.mul(e.b,At);let O=n.mul(h,x),V=n.mul(g,v),P=n.mul(w,S),nt=n.add(h,g),b=n.add(x,v);nt=n.mul(nt,b),b=n.add(O,V),nt=n.sub(nt,b),b=n.add(h,w);let y=n.add(x,S);return b=n.mul(b,y),y=n.add(O,P),b=n.sub(b,y),y=n.add(g,w),m=n.add(v,S),y=n.mul(y,m),m=n.add(V,P),y=n.sub(y,m),A=n.mul($,b),m=n.mul(q,P),A=n.add(m,A),m=n.sub(V,A),A=n.add(V,A),_=n.mul(m,A),V=n.add(O,O),V=n.add(V,O),P=n.mul($,P),b=n.mul(q,b),V=n.add(V,P),P=n.sub(O,P),P=n.mul($,P),b=n.add(b,P),O=n.mul(V,b),_=n.add(_,O),O=n.mul(y,b),m=n.mul(nt,m),m=n.sub(m,O),O=n.mul(nt,V),A=n.mul(y,A),A=n.add(A,O),new a(m,_,A)}subtract(l){return this.add(l.negate())}is0(){return this.equals(a.ZERO)}wNAF(l){return B.wNAFCached(this,u,l,h=>{const g=n.invertBatch(h.map(w=>w.pz));return h.map((w,x)=>w.toAffine(g[x])).map(a.fromAffine)})}multiplyUnsafe(l){const h=a.ZERO;if(l===K)return h;if(i(l),l===N)return this;const{endo:g}=e;if(!g)return B.unsafeLadder(this,l);let{k1neg:w,k1:x,k2neg:v,k2:S}=g.splitScalar(l),m=h,_=h,A=this;for(;x>K||S>K;)x&N&&(m=m.add(A)),S&N&&(_=_.add(A)),A=A.double(),x>>=N,S>>=N;return w&&(m=m.negate()),v&&(_=_.negate()),_=new a(n.mul(_.px,g.beta),_.py,_.pz),m.add(_)}multiply(l){i(l);let g,w,h=l;const{endo:x}=e;if(x){const{k1neg:v,k1:S,k2neg:m,k2:_}=x.splitScalar(h);let{p:A,f:$}=this.wNAF(S),{p:q,f:O}=this.wNAF(_);A=B.constTimeNegate(v,A),q=B.constTimeNegate(m,q),q=new a(n.mul(q.px,x.beta),q.py,q.pz),g=A.add(q),w=$.add(O)}else{const{p:v,f:S}=this.wNAF(h);g=v,w=S}return a.normalizeZ([g,w])[0]}multiplyAndAddUnsafe(l,h,g){const w=a.BASE,x=(S,m)=>m!==K&&m!==N&&S.equals(w)?S.multiply(m):S.multiplyUnsafe(m),v=x(this,h).add(x(l,g));return v.is0()?void 0:v}toAffine(l){const{px:h,py:g,pz:w}=this,x=this.is0();null==l&&(l=x?n.ONE:n.inv(w));const v=n.mul(h,l),S=n.mul(g,l),m=n.mul(w,l);if(x)return{x:n.ZERO,y:n.ZERO};if(!n.eql(m,n.ONE))throw new Error("invZ was invalid");return{x:v,y:S}}isTorsionFree(){const{h:l,isTorsionFree:h}=e;if(l===N)return!0;if(h)return h(a,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:h}=e;return l===N?this:h?h(a,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return this.assertValidity(),r(a,this,l)}toHex(l=!0){return ut(this.toRawBytes(l))}}a.BASE=new a(e.Gx,e.Gy,n.ONE),a.ZERO=new a(n.ZERO,n.ONE,n.ZERO);const E=e.nBitLength,B=function yn(t,e){const n=(o,s)=>{const c=s.negate();return o?c:s},r=o=>({windows:Math.ceil(e/o)+1,windowSize:2**(o-1)});return{constTimeNegate:n,unsafeLadder(o,s){let c=t.ZERO,i=o;for(;s>wn;)s&Xt&&(c=c.add(i)),i=i.double(),s>>=Xt;return c},precomputeWindow(o,s){const{windows:c,windowSize:i}=r(s),f=[];let u=o,d=u;for(let a=0;a<c;a++){d=u,f.push(d);for(let E=1;E<i;E++)d=d.add(u),f.push(d);u=d.double()}return f},wNAF(o,s,c){const{windows:i,windowSize:f}=r(o);let u=t.ZERO,d=t.BASE;const a=BigInt(2**o-1),E=2**o,B=BigInt(o);for(let p=0;p<i;p++){const l=p*f;let h=Number(c&a);c>>=B,h>f&&(h-=E,c+=Xt);const g=l,w=l+Math.abs(h)-1,v=h<0;0===h?d=d.add(n(p%2!=0,s[g])):u=u.add(n(v,s[w]))}return{p:u,f:d}},wNAFCached(o,s,c,i){const f=o._WINDOW_SIZE||1;let u=s.get(o);return u||(u=this.precomputeWindow(o,f),1!==f&&s.set(o,i(u))),this.wNAF(f,u,c)}}}(a,e.endo?Math.ceil(E/2):E);return{CURVE:e,ProjectivePoint:a,normPrivateKeyToScalar:f,weierstrassEquation:s,isWithinCurveOrder:c}}({...e,toBytes(b,y,I){const T=y.toAffine(),U=n.toBytes(T.x),R=ct;return I?R(Uint8Array.from([y.hasEvenY()?2:3]),U):R(Uint8Array.from([4]),U,n.toBytes(T.y))},fromBytes(b){const y=b.length,I=b[0],T=b.subarray(1);if(y!==o||2!==I&&3!==I){if(y===s&&4===I)return{x:n.fromBytes(T.subarray(0,n.BYTES)),y:n.fromBytes(T.subarray(n.BYTES,2*n.BYTES))};throw new Error(`Point of length ${y} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}{const U=j(T);if(!function c(b){return K<b&&b<n.ORDER}(U))throw new Error("Point is not on curve");const R=a(U);let Z=n.sqrt(R);return!(1&~I)!=((Z&N)===N)&&(Z=n.neg(Z)),{x:U,y:Z}}}}),B=b=>ut(Q(b,e.nByteLength));function p(b){return b>r>>N}const h=(b,y,I)=>j(b.slice(y,I));class g{constructor(y,I,T){this.r=y,this.s=I,this.recovery=T,this.assertValidity()}static fromCompact(y){const I=e.nByteLength;return y=C("compactSignature",y,2*I),new g(h(y,0,I),h(y,I,2*I))}static fromDER(y){const{r:I,s:T}=ft.toSig(C("DER",y));return new g(I,T)}assertValidity(){if(!E(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!E(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new g(this.r,this.s,y)}recoverPublicKey(y){const{r:I,s:T,recovery:U}=this,R=_(C("msgHash",y));if(null==U||![0,1,2,3].includes(U))throw new Error("recovery id invalid");const Z=2===U||3===U?I+e.n:I;if(Z>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const rt=u.fromHex((1&U?"03":"02")+B(Z)),ot=f(Z),ht=i(-R*ot),Et=i(T*ot),st=u.BASE.multiplyAndAddUnsafe(rt,ht,Et);if(!st)throw new Error("point at infinify");return st.assertValidity(),st}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return lt(this.toDERHex())}toDERHex(){return ft.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return lt(this.toCompactHex())}toCompactHex(){return B(this.r)+B(this.s)}}const w={isValidPrivateKey(b){try{return d(b),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const b=Be(e.n);return function bn(t,e,n=!1){const r=t.length,o=Ee(e),s=Be(e);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const i=k(n?j(t):zt(t),e-L)+L;return n?Kt(i,o):Q(i,o)}(e.randomBytes(b),e.n)},precompute:(b=8,y=u.BASE)=>(y._setWindowSize(b),y.multiply(BigInt(3)),y)};function v(b){const y=b instanceof Uint8Array,I="string"==typeof b,T=(y||I)&&b.length;return y?T===o||T===s:I?T===2*o||T===2*s:b instanceof u}const m=e.bits2int||function(b){const y=j(b),I=8*b.length-e.nBitLength;return I>0?y>>BigInt(I):y},_=e.bits2int_modN||function(b){return i(m(b))},A=Gt(e.nBitLength);function $(b){if("bigint"!=typeof b)throw new Error("bigint expected");if(!(K<=b&&b<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Q(b,e.nByteLength)}const O={lowS:e.lowS,prehash:!1},V={lowS:e.lowS,prehash:!1};return u.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function x(b,y=!0){return u.fromPrivateKey(b).toRawBytes(y)},getSharedSecret:function S(b,y,I=!0){if(v(b))throw new Error("first arg must be private key");if(!v(y))throw new Error("second arg must be public key");return u.fromHex(y).multiply(d(b)).toRawBytes(I)},sign:function P(b,y,I=O){const{seed:T,k2sig:U}=function q(b,y,I=O){if(["recovered","canonical"].some(at=>at in I))throw new Error("sign() legacy options not supported");const{hash:T,randomBytes:U}=e;let{lowS:R,prehash:Z,extraEntropy:D}=I;null==R&&(R=!0),b=C("msgHash",b),Z&&(b=C("prehashed msgHash",T(b)));const rt=_(b),ot=d(y),ht=[$(ot),$(rt)];if(null!=D){const at=!0===D?U(n.BYTES):D;ht.push(C("extraEntropy",at))}const Et=ct(...ht),st=rt;return{seed:Et,k2sig:function ae(at){const gt=m(at);if(!E(gt))return;const $e=f(gt),W=u.BASE.multiply(gt).toAffine(),bt=i(W.x);if(bt===K)return;const kt=i($e*i(st+bt*ot));if(kt===K)return;let je=(W.x===bt?0:2)|Number(W.y&N),Ve=kt;return R&&p(kt)&&(Ve=function l(b){return p(b)?i(-b):b}(kt),je^=1),new g(bt,Ve,je)}}}(b,y,I);return pe(e.hash.outputLen,e.nByteLength,e.hmac)(T,U)},verify:function nt(b,y,I,T=V){const U=b;if(y=C("msgHash",y),I=C("publicKey",I),"strict"in T)throw new Error("options.strict was renamed to lowS");const{lowS:R,prehash:Z}=T;let D,rt;try{if("string"==typeof U||U instanceof Uint8Array)try{D=g.fromDER(U)}catch(W){if(!(W instanceof ft.Err))throw W;D=g.fromCompact(U)}else{if("object"!=typeof U||"bigint"!=typeof U.r||"bigint"!=typeof U.s)throw new Error("PARSE");{const{r:W,s:bt}=U;D=new g(W,bt)}}rt=u.fromHex(I)}catch(W){if("PARSE"===W.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(R&&D.hasHighS())return!1;Z&&(y=e.hash(y));const{r:ot,s:ht}=D,Et=_(y),st=f(ht),ae=i(Et*st),at=i(ot*st),gt=u.BASE.multiplyAndAddUnsafe(rt,ae,at)?.toAffine();return!!gt&&i(gt.x)===ot},ProjectivePoint:u,Signature:g,utils:w}}function An(t){return{hash:t,hmac:(e,...n)=>ve(t,e,function Ke(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Vt(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}(...n)),randomBytes:he}}BigInt(4);const St=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),It=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ie=BigInt(1),Ot=BigInt(2),Oe=(t,e)=>(t+e/Ot)/e;function Le(t){const e=St,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),i=BigInt(44),f=BigInt(88),u=t*t*t%e,d=u*u*t%e,a=z(d,n,e)*d%e,E=z(a,n,e)*d%e,B=z(E,Ot,e)*u%e,p=z(B,o,e)*B%e,l=z(p,s,e)*p%e,h=z(l,i,e)*l%e,g=z(h,f,e)*h%e,w=z(g,i,e)*l%e,x=z(w,n,e)*d%e,v=z(x,c,e)*p%e,S=z(v,r,e)*u%e,m=z(S,Ot,e);if(!Qt.eql(Qt.sqr(m),t))throw new Error("Cannot find square root");return m}const Qt=function gn(t,e,n=!1,r={}){if(t<=H)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=Yt(t,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=function an(t){if(t%Wt===rn){const e=(t+L)/Wt;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%me===xe){const e=(t-xe)/me;return function(r,o){const s=r.mul(o,J),c=r.pow(s,e),i=r.mul(o,c),f=r.mul(r.mul(i,J),c),u=r.mul(i,r.sub(f,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return function fn(t){const e=(t-L)/J;let n,r,o;for(n=t-L,r=0;n%J===H;n/=J,r++);for(o=J;o<t&&cn(o,e,t)!==t-L;o++);if(1===r){const c=(t+L)/Wt;return function(f,u){const d=f.pow(u,c);if(!f.eql(f.sqr(d),u))throw new Error("Cannot find square root");return d}}const s=(n+L)/J;return function(i,f){if(i.pow(f,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let u=r,d=i.pow(i.mul(i.ONE,o),n),a=i.pow(f,s),E=i.pow(f,n);for(;!i.eql(E,i.ONE);){if(i.eql(E,i.ZERO))return i.ZERO;let B=1;for(let l=i.sqr(E);B<u&&!i.eql(l,i.ONE);B++)l=i.sqr(l);const p=i.pow(d,L<<BigInt(u-B-1));d=i.sqr(p),a=i.mul(a,p),E=i.mul(E,d),u=B}return a}}(t)}(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Gt(o),ZERO:H,ONE:L,create:f=>k(f,t),isValid:f=>{if("bigint"!=typeof f)throw new Error("Invalid field element: expected bigint, got "+typeof f);return H<=f&&f<t},is0:f=>f===H,isOdd:f=>(f&L)===L,neg:f=>k(-f,t),eql:(f,u)=>f===u,sqr:f=>k(f*f,t),add:(f,u)=>k(f+u,t),sub:(f,u)=>k(f-u,t),mul:(f,u)=>k(f*u,t),pow:(f,u)=>function dn(t,e,n){if(n<H)throw new Error("Expected power > 0");if(n===H)return t.ONE;if(n===L)return e;let r=t.ONE,o=e;for(;n>H;)n&L&&(r=t.mul(r,o)),o=t.sqr(o),n>>=L;return r}(i,f,u),div:(f,u)=>k(f*vt(u,t),t),sqrN:f=>f*f,addN:(f,u)=>f+u,subN:(f,u)=>f-u,mulN:(f,u)=>f*u,inv:f=>vt(f,t),sqrt:r.sqrt||(f=>c(i,f)),invertBatch:f=>function hn(t,e){const n=new Array(e.length),r=e.reduce((s,c,i)=>t.is0(c)?s:(n[i]=s,t.mul(s,c)),t.ONE),o=t.inv(r);return e.reduceRight((s,c,i)=>t.is0(c)?s:(n[i]=t.mul(s,n[i]),t.mul(s,c)),o),n}(i,f),cmov:(f,u,d)=>d?u:f,toBytes:f=>n?Kt(f,s):Q(f,s),fromBytes:f=>{if(f.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${f.length}`);return n?zt(f):j(f)}});return Object.freeze(i)}(St,void 0,void 0,{sqrt:Le}),Jt=function Sn(t,e){const n=r=>_n({...t,...An(r)});return Object.freeze({...n(e),create:n})}({a:BigInt(0),b:BigInt(7),Fp:Qt,n:It,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=It,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ie*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,c=BigInt("0x100000000000000000000000000000000"),i=Oe(s*t,e),f=Oe(-r*t,e);let u=k(t-i*n-f*o,e),d=k(-i*r-f*s,e);const a=u>c,E=d>c;if(a&&(u=e-u),E&&(d=e-d),u>c||d>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:a,k1:u,k2neg:E,k2:d}}}},Dt),Lt=BigInt(0),Ue=t=>"bigint"==typeof t&&Lt<t&&t<St,Te={};function Ut(t,...e){let n=Te[t];if(void 0===n){const r=Dt(Uint8Array.from(t,o=>o.charCodeAt(0)));n=ct(r,r),Te[t]=n}return Dt(ct(n,...e))}const Ft=t=>t.toRawBytes(!0).slice(1),te=t=>Q(t,32),ee=t=>k(t,St),xt=t=>k(t,It),ne=Jt.ProjectivePoint;function re(t){let e=Jt.utils.normPrivateKeyToScalar(t),n=ne.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:xt(-e),bytes:Ft(n)}}function qe(t){if(!Ue(t))throw new Error("bad x: need 0 < x < p");const e=ee(t*t);let r=Le(ee(e*t+BigInt(7)));r%Ot!==Lt&&(r=ee(-r));const o=new ne(t,r,Ie);return o.assertValidity(),o}function Ne(...t){return xt(j(Ut("BIP0340/challenge",...t)))}function He(t,e,n){const r=C("signature",t,64),o=C("message",e),s=C("publicKey",n,32);try{const c=qe(j(s)),i=j(r.subarray(0,32));if(!Ue(i))return!1;const f=j(r.subarray(32,64));if(!(t=>"bigint"==typeof t&&Lt<t&&t<It)(f))return!1;const u=Ne(te(i),Ft(c),o),d=((t,e,n)=>ne.BASE.multiplyAndAddUnsafe(t,e,n))(c,f,xt(-u));return!(!d||!d.hasEvenY()||d.toAffine().x!==i)}catch{return!1}}const mt={getPublicKey:function Ln(t){return re(t).bytes},sign:function Un(t,e,n=he(32)){const r=C("message",t),{bytes:o,scalar:s}=re(e),c=C("auxRand",n,32),i=te(s^j(Ut("BIP0340/aux",c))),f=Ut("BIP0340/nonce",i,o,r),u=xt(j(f));if(u===Lt)throw new Error("sign failed: k is zero");const{bytes:d,scalar:a}=re(u),E=Ne(d,o,r),B=new Uint8Array(64);if(B.set(d,0),B.set(te(xt(a+E*s)),32),!He(B,r,o))throw new Error("sign: Invalid signature produced");return B},verify:He,utils:{randomPrivateKey:Jt.utils.randomPrivateKey,lift_x:qe,pointToBytes:Ft,numberToBytesBE:Q,bytesToNumberBE:j,taggedHash:Ut,mod:k}},oe=("object"==typeof globalThis&&"crypto"in globalThis&&globalThis,t=>t instanceof Uint8Array),se=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),M=(t,e)=>t<<32-e|t>>>e;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");const Tn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Tt(t){if(!oe(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Tn[t[n]];return e}function qt(t){if("string"==typeof t&&(t=function Nn(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!oe(t))throw new Error("expected Uint8Array, got "+typeof t);return t}class Hn{clone(){return this._cloneInto()}}function ke(t){const e=r=>t().update(qt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Re(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}const fe_exists=function $n(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},fe_output=function jn(t,e){Re(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)};class Pn extends Hn{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=se(this.buffer)}update(e){fe_exists(this);const{view:n,buffer:r,blockLen:o}=this,s=(e=qt(e)).length;for(let c=0;c<s;){const i=Math.min(o-this.pos,s-c);if(i!==o)r.set(e.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===o&&(this.process(n,0),this.pos=0);else{const f=se(e);for(;o<=s-c;c+=o)this.process(f,c)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){fe_exists(this),fe_output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:c}=this;n[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let a=c;a<o;a++)n[a]=0;(function Vn(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),c=Number(n>>o&s),i=Number(n&s),u=r?0:4;t.setUint32(e+(r?4:0),c,r),t.setUint32(e+u,i,r)})(r,o-8,BigInt(8*this.length),s),this.process(r,0);const i=se(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=f/4,d=this.get();if(u>d.length)throw new Error("_sha2: outputLen bigger than state");for(let a=0;a<u;a++)i.setUint32(4*a,d[a],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:c,pos:i}=this;return e.length=o,e.pos=i,e.finished=s,e.destroyed=c,o%n&&e.buffer.set(r),e}}const Zn=(t,e,n)=>t&e^~t&n,Dn=(t,e,n)=>t&e^t&n^e&n,zn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),et=new Uint32Array(64);class Ce extends Pn{constructor(){super(64,32,8,!1),this.A=0|tt[0],this.B=0|tt[1],this.C=0|tt[2],this.D=0|tt[3],this.E=0|tt[4],this.F=0|tt[5],this.G=0|tt[6],this.H=0|tt[7]}get(){const{A:e,B:n,C:r,D:o,E:s,F:c,G:i,H:f}=this;return[e,n,r,o,s,c,i,f]}set(e,n,r,o,s,c,i,f){this.A=0|e,this.B=0|n,this.C=0|r,this.D=0|o,this.E=0|s,this.F=0|c,this.G=0|i,this.H=0|f}process(e,n){for(let a=0;a<16;a++,n+=4)et[a]=e.getUint32(n,!1);for(let a=16;a<64;a++){const E=et[a-15],B=et[a-2],p=M(E,7)^M(E,18)^E>>>3,l=M(B,17)^M(B,19)^B>>>10;et[a]=l+et[a-7]+p+et[a-16]|0}let{A:r,B:o,C:s,D:c,E:i,F:f,G:u,H:d}=this;for(let a=0;a<64;a++){const B=d+(M(i,6)^M(i,11)^M(i,25))+Zn(i,f,u)+zn[a]+et[a]|0,l=(M(r,2)^M(r,13)^M(r,22))+Dn(r,o,s)|0;d=u,u=f,f=i,i=c+B|0,c=s,s=o,o=r,r=B+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,i=i+this.E|0,f=f+this.F|0,u=u+this.G|0,d=d+this.H|0,this.set(r,o,s,c,i,f,u,d)}roundClean(){et.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class Kn extends Ce{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Gn=ke(()=>new Ce);ke(()=>new Kn);var dt=Symbol("verified"),Mn=t=>t instanceof Object;new TextDecoder("utf-8");var Yn=new TextEncoder;function Nt(t){return Tt(Gn(Yn.encode(function Qn(t){if(!function Wn(t){if(!Mn(t)||"number"!=typeof t.kind||"string"!=typeof t.content||"number"!=typeof t.created_at||"string"!=typeof t.pubkey||!t.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(t.tags))return!1;for(let e=0;e<t.tags.length;e++){let n=t.tags[e];if(!Array.isArray(n))return!1;for(let r=0;r<n.length;r++)if("object"==typeof n[r])return!1}return!0}(t))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content])}(t))))}function Jn(t){let e=0;for(let n=0;n<t.length;n++){const r=parseInt(t[n],16);if(0!==r){e+=Math.clz32(r)-28;break}e+=4}return e}new class{generateSecretKey(){return mt.utils.randomPrivateKey()}getPublicKey(t){return Tt(mt.getPublicKey(t))}finalizeEvent(t,e){const n=t;return n.pubkey=Tt(mt.getPublicKey(e)),n.id=Nt(n),n.sig=Tt(mt.sign(Nt(n),e)),n[dt]=!0,n}verifyEvent(t){if("boolean"==typeof t[dt])return t[dt];const e=Nt(t);if(e!==t.id)return t[dt]=!1,!1;try{const n=mt.verify(t.sig,e,t.pubkey);return t[dt]=n,n}catch{return t[dt]=!1,!1}}},addEventListener("message",({data:t})=>{const e=function Fn(t,e){let n=0;const r=t,o=["nonce",n.toString(),e.toString()];for(r.tags.push(o);;){const s=Math.floor((new Date).getTime()/1e3);if(s!==r.created_at&&(n=0,r.created_at=s),o[1]=(++n).toString(),r.id=Nt(r),Jn(r.id)>=e)break}return r}(t,10);postMessage({data:e})})})();